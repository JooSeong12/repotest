class : 객체를 만들어 내기 위한 설계도 혹은 틀이며 연관되어 있는 변수와 메서드의 집합
클래스는 변수로 생각해야한다.
ex) people이라는 클래스가 있다고 가정
public class people{
변수, 메서드 등을 가질 수 있음
}

클래스 생성 시 약속
1. private 선언하자
2. getter, setter를 만들어주자 >> 변수의 값을 변경하거나 읽어올 수 있는 통로를 만들어주자
==================================================================================================================================
객체(object) : 소프트웨어 세계에서 구현할 대상, 클래스에 선언된 모양 그대로 생성된 실체
                  클래스의 인스턴스(instance)라고도 부르며 객체는 모든 인스턴스를 대표하는 포괄적인 의미
인스턴스(instance) : 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
                           객체를 소프트웨어에 실체화하면 그것을 인스턴스라고 부르고 실체화된 인스턴스는 메모리에 할당된다.

전역변수(Global variable)와 지역변수(Local variables)는 선언 위치에따라 나뉜다
전역변수는 어디서든 호출하면 사용할 수 있는 변수(클래스 네임 바로 밑에 선언하는 변수들)
지역변수는 특정한 구역{ }안에 생성되어 그 지역에서만 사용할 수 있는 변수(메서드 안에 선언되는 변수들)

전역변수의 종류
객체변수(인스턴스 변수) : 클래스의 객체를 생성할 때 만들어지며 객체화를 시켜야만 호출 가능 ex) int i; 
클래스변수(static 변수) : 객체화 시키지 않아도 사용 가능 ex) static int i;

클래스의 구성
필드 : 필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳입니다. 선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지는 않습니다.
        필드는 클래스 내부이면서 메소드와 생성자의 밖에 존재하는 것을 뜻한다.(전역변수의 위치를 생각하면 됨)
생성자 : new 연산자로 호출되는 특별한 중괄호 {} 블록입니다. 생성자의 역할은 객체 생성 시 초기화를 담당합니다. 
메서드 : 메서드는 객체 간의 데이터 전달의 수단
==================================================================================================================================
메모리구조
Static : 전역변수와 정적 멤버변수(static이 붙은 자료형)가 static영역에 저장되며 프로그램 시작부터 종료까지 메모리에 남아있는다.

Stack : 메소드 내에서 정의하는 기본 자료형(int, boolean 등)에 해당되는 지역변수의 데이터값이 저장되는 공간
          메소드가 호출될 때 메모리에 할당되고 종료시 사라짐

Heap : 참조형(Reference Type)의 데이터 타입을 갖는 객체(인스턴스), 배열 등은 Heap 영역에 데이터가 저장
          변수는 스택영역의 공간에서 실제 데이터가 저장된 heap 영역의 참조값을 new연산자를 통해 리턴받는다.
          즉 heap영역은 데이터를 저장해놓고 스택에서 참조해 쓰는 영역
==================================================================================================================================
오버로딩(Overloading)
1개의 클래스에서 동일한 이름의 메소드 또는 생성자를 여러개 정의하는 것을 의미한다.
동일한 이름을 갖고 매개변수의 자료형, 개수, 순서를 다르게 하여 선언하여야 한다.

인스턴스 멤버
인스턴스가 가지고 있는 필드(Field) 및 메소드(Method)를 의미하며 이들은 인스턴스 필드, 인스턴스 메소드라고 부른다.
ex) Car car = new Car() >> 인스턴스 생성 및 생성자 호출
     car.speedUp(); >> 인스턴스 메소드 호출
즉 인스턴스를 생성한 후 해당 인스턴스가 가지고 있는 필드 및 메소드를 인스턴스 멤버라고 한다.
(여기 예시에서는 speedUp()메소드가 인스턴스 메소드임)

정적멤버(클래스멤버)
정적(static) 멤버는 클래스에 소속된 멤버(필드, 메소드)를 의미한다. 
간단히 말하면 static이라는 키워드가 붙은 필드(전역변수) 또는 메소드가 정적 멤버이다.

정적 필드(변수)는 인스턴스 생성 없이 클래스로 호출이 가능하기 때문에 여러 인스턴스들이 동일한 데이터를 사용할 때
공유의 목적으로 사용하는것이다.

정적 메소드도 정적 필드와 동일한 목적이지만 정적메소드에서는 정적 필드만 사용이 가능하다.
==================================================================================================================================
상속(Inheritance)
자식 클래스가 부모 클래스로부터 상속을 받게 되면 부모 클래스의 필드와 메서드를 물려받게 된다.
단, 접근제어자가 private를 갖는 필드나 메소드는 상속 불가
상속을 받으면 중복된 코드를 줄이고 유지보수가 편하다.
자식클래스가 여러 부모로부터 다중 상속을 받는 것은 불가하고 1개의 부모 클래스로부터 단일 상속만 허용
하지만 부모클래스는 여러개의 자식 클래스에게 상속 가능

상속에서의 생성자
기본적으로 생성자는 상속되지 않는다.
자식 클래스로 인스턴스를 생성할 때 부모 클래스의 기본 생성자는 자동으로 호출이 된다.
하지만 부모 클래스에 매개변수를 갖는 생성자가 있다면 이 생성자는 자동으로 호출 되지 않으며
해당 생성자를 호출 하고 싶다면 자식 생성자 안에 super();라는 키워드를 첫줄에 작성해야한다.
super();의 괄호 안에는 부모 클래스의 매개변수 생성자와 동일한 매개변수를 넣어줘야한다.
==================================================================================================================================
싱글톤(Singleton) 패턴
하나의 해당 클레스에서 단 하나의 인스턴스만 만들도록 보장하는 방법
하나의 인스턴스만을 재사용함으로서 불필요한 자원 낭비나 오버헤드 등을 방지

1. 외부에서 생성자를 호출할 수 없도록 제한, 즉 생성자의 접근제어자를 private로 사용
2. 자신의 클래스 타입으로 정적(static) 필드를 선언하고 자신의 인스턴스를 생성 접근제어자도 private
3. 외부에서 호출이 가능한 정적 메소드인 getInstance()를 정의, 정적필드에서 생성한 인스턴스를 리턴값으로 돌려줌
   외부 클래스에서 싱글톤으로 정의된 클래스의 인스턴스를 얻기 위해서는 getInstance()메서드를 호출해야함
그렇다면 아래의 모양이 된다.

class 클래스명 {
private static 클래스명 객체명 = new 클래스명(); // 자신의 인스턴스 생성
private 클래스명(){} // 생성자 호출 제한
public static 클래스명 getInstance(){ // getInstance 메서드 정의
return 객체명; // 생성한 인스턴스를 리턴
}
}
==================================================================================================================================
오버라이딩(overriding)
부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하여 사용하는 것
자식 클래스에서 부모 클래스의 메소드를 재정의 하기위해서는 조건을 지켜야한다.
부모 메소드의 이름, 리턴타입, 매개변수의 갯수, 자료형과 순서를 동일하게 해야한다.
==================================================================================================================================
추상클래스
abstract 키워를 class 앞에 선언
ex) abstract class 클래스명{}
추상메서드도 동일하게 abstract 리턴타입 메소드명(매개변수); >> 얘는 중괄호 없이 바로 ;으로 종료

추상 클래스 및 메소드 특징
1. 자체적으로 객체를 생성할 수 없고, 상속을 통해 자식클래스에서 인스턴스를 생성해야함
2. 추상클래스는 추상 메소드, 일반 메소드, 필드, 생성자로 구성
3. 일반적인 상속의 특성과 동일
4. 추상클래스를 상속받는 클래스는 반드시 추상 메소드를 오버라이딩해야한다.

추상클래스를 사용하는 이유는 다수의 사람이 개발에 참여할 때 공통된 내용들은
통일되게 작성하도록 규격화하기 위함이다.

final
변경이나 수정을 금지하는 것

final field
final을 가장 많이 사용하는 곳은 필드이다.
final로 변수값을 지정하면 다른곳에서 변경이 불가하다.

final class
final class의 의미는 상속이 불가능하다는것을 의미한다.

final method
final method의 의미는 오버라이딩을 금지할 때 사용

==================================================================================================================================
인터페이스(interface) : 코드와 인스턴스(객체)를 연결하는 접점, 인터페이스를 구현하는 인스턴스(객체)들은 동일한 이름의 메서드를 오버라이딩하도록 강제

인터페이스 구성 멤버
1. 상수 : 인터페이스에서는 상수 필드만 선언이 가능(일반 변수 선언 불가) 컴파일 과정에서 자동적으로 public static final이 붙는다.
             ex) double PI = 3.14라고 선언을 한다면 public static final double PI = 3.14와 같은 의미가 된다.
2. 추상메소드 : abstract 키워드가 붙은 메소드를 의미하고 블록문이 없는 시그니쳐(타입, 메소드명 등)와 매개변수로만 정의된 메소드
                     인터페이스에서 메소드를 정의하면 public abstract를 생략하여도 자동적으로 컴파일 과정에서 붙게 된다.
                      ex) 인터페이스에서 void method();를 정의하면 public abstract void method();인 추상메소드가 된다.
3. 디폴트 메소드 : 실행블록을 가지고 있으며 default 키워드를 반드시 명시해야한다.
                        ex) default void dfmethod(){ .... }
4. 정적 메소드 : 실행블록을 가지고 있으며 static 키워드를 반드시 명시해야한다.
                        ex) static void stmethod(){ .... }

인터페이스 구현
인터페이스는 생성자가 없기때문에 인터페이스 자체로는 인스턴스(객체)를 생성할 수 없다.
또한 인터페이스는 추상메소드를 갖기 때문에 이것을 구체화할 대상이 필요하고 그 대상은 클래스(객체)이며 구체화 시키는 것을 구현한다고 한다.
구현방법은 구현할 클래스 뒤에 implements 인터페이스명을 명시하면 된다.
ex) public class 클래스명 implements 인터페이스명

인터페이스 사용이유
인터페이스는 일종의 양식을 제공한다고 생각하면 된다. 인터페이스를 구현하는 클래스들은 추상메소드를 반드시 오버라이딩 해야한다.
이 뜻은 여러 클래스가 하나의 인터페이스를 구현한다면 동일한 추상메소드를 사용해서 코드를 만들어간다.
이는 여러 개발자가 프로젝트를 진행할 때 통일성 있는 설계가 가능하게 해준다.
또한 구현한 클래스들에 따라서 하나의 인터페이스로 다양한 실행 결과를 얻을 수 있다. 이것을 다형성이라고 한다.

인터페이스 특징
인터페이스가 추상클래스와 차이점이 없어보이지만 가장큰 특징이자 차이점은 다중 상속이다.
여러 인터페이스를 하나의 클래스에서 구현이 가능하고 인터페이스끼리 상속도 가능하다.
또한 추상클래스도 인터페이스를 상속 받을 수 있지만 인터페이스는 추상클래스를 상속받지 못한다.(인터페이스가 추상클래스보다는 큰 개념이라고 생각하자)

==================================================================================================================================
래퍼(wrapper) 클래스와 박싱 언박싱

래퍼클래스 : 기본 자료형(int, double, boolean등)의 데이터를 인스턴스(객체)로 만들기 위해 사용(포장)하는 클래스

래퍼클래스 사용이유 : 제네릭, 자료구조, 매개변수 등 기본 자료형이 아닌 레퍼런스 타입(참조형 타입 : 클래스, 인터페이스 등)을 필요로 하는 경우가 많고
                               메서드를 갖고 있어 다양하게 활용이 가능하기 때문이다. 또한 인스턴스를 생성하여 상속 및 재사용이 가능하고
                               문자열과 기본 자료형 간 형 변환하여 사용가능

래퍼클래스의 종류
기본 데이터 타입의 앞글자를 대문자로 바꿔주면 된다.
byte > Byte, char > Character, int > Integer, long > Long 등등

박싱, 언박싱
박싱은 기본 자료형의 데이터를 래퍼클래스의 객체로 만드는 과정을 의미, 언박싱은 반대

박싱하는 방법
new 연산자를 사용하는 방법 : Byte 객체명 = new Byte(정수);
ex) int i = 10;      Integer wi = new Integer(i)
String을 매개변수로해도 가능하다.
ex) String str = "10";       Integer wi2 = new Integer(str);

valueOf()메서드를 사용하는 방법
ex) int i = 10;      Integer wi = Integer.valueOf(i);
동일하게 String도 가능

언방식하는 방법
기본 자료형Value();의 메소드를 사용하는 방법
ex) int i = 10;     Integer wi = new Integer(i);          int i2 = wo.intValue();
==================================================================================================================================
문자열 형 변환(String ↔ 기본 자료형(int, double 등))

String → 기본 자료형(int, double, boolean, byte, short, long, float)
1. 래퍼클래스로 객체를 생성할 때 매개변수에 Stringdmf 넘겨주고 생성된 객체를 기본 자료형으로 언박싱하는 방법
위의 언방식하는 방법 예시와 동일

2. 래퍼 클래스에서 지원하는 정적 메소드를 사용하는 방법 : parse기본자료형(문자열)의 형태
ex) int i = Integer.parseInt("10");


기본 자료형(int, double, boolean, byte, short, long, float) → String
1. 기본자료형을 래퍼클래스로 박싱 후 toString()으로 변환
ex) Integer wi = new Integer(10);       String str = wi.toString();

2. 래퍼 클래스의 정적 메소드인 toString(기본자료형 데이터)을 이용하여 변환
ex) String str = Integer.toString(10);

3.  String 클래스의 정적 메소드인 valueOf(기본자료형 데이터)를 이용
ex) String str = String.valueOf(10);

4. 기본 자료형의 데이터와 아무런 내용이 없는 ""를 결합
ex) String str = 10 + "";

==================================================================================================================================
레퍼런스(reference) 형 변환(업 캐스팅, 다운 캐스팅)

레퍼런스 형번환 : 레퍼런스 타입간의 형 변환하는 것을 의미, 클래스 간 상속관계에 있거나 인터페이스를 구현하는 부모-자식 관계에 있는 경우에만 형 변환이 가능

업캐스팅 : 서브 클래스에서 슈퍼 클래스로 형변환 하는것을 의미
               부모 객체로 자식 객체의 멤버를 사용할 수 있다. 단, 부모가 갖고 있는 멤버에 한해서만 참조가 가능
               이 때 형변환 시 자동 타입 변환(부모타입 생략)이 가능하다.
업스캐팅 방법
1. 자식타입 자식객체명 = new 자식타입();
   부모타입 부모객체명 = (부모타입)자식객체명;   (부모타입) 부분은 자동타입변환으로 생략가능

2. 부모타입 부모객체명 = new 자식객체명;


다운캐스팅 : 부모 타입을 자식 타입으로 변환하는 것
                  자식 타입의 멤버의 사용이 필요한 경우 다운 캐스팅 사용, 부모타입 모두를 자식 타입으로 형 변환이 가능한 것은 아니다.
                  다운캐스팅을 성립하기 위한 조건은 부모 타입으로 업캐스팅을 선행한 후 다시 자식 타입으로 변환할 때 사용가능(안그러면 컴파일에러)
다운캐스팅 방법
부모타입 부모객체명 = new 자식타입(); //업 캐스팅
자식타입 자식객체명 = (자식타입)부모객체명 // 다운캐스팅
==================================================================================================================================
다형성(polymorphism)의 개념/의미/예제

다형성 : 같은 자료형에 여러 가지 객체를 대입하여 다양한 결과를 얻어내는 성질을 의미
ex) 오버워치에서 좌클릭하면 평타나감 하지만 캐릭터마다 평타는 모두 다르다
     즉 오버워치라는 하나의 인터페이스에서 그것을 구현하는 각 캐릭터(객체)들에 대해 동일한 버튼(메소드 오버라이딩)을 클릭하여 서로 다른 스킬을 사용하게 된다(다형성)

다형성의 효과 : 하나의 타입으로 다양한 실행 결과를 얻을 수 있으며 객체를 부품화하여 유지 보수를 용이하게 한다.

다형성 구현 방법
자식 클래스에서 메서드를 재정의(오버라이딩) 하고 자식 클래스를 부모 타입으로 업캐스팅한다. 그리고 부모 타입의 객체에서 자식 멤버를 참조하여 다형성을 구현

interface OverWatch { // 인터페이스
	void name(); // 추상 메소드
	void lClick(); // 추상 메소드
	void rClick(); // 추상 메소드
	void shiftButton(); // 추상 메소드
	void eButton(); // 추상 메소드
	void qButton(); // 추상 메소드
}

class Mei implements OverWatch { // 인터페이스 구현 클래스
	public void name() { // 오버라이딩
		System.out.println("이름 : 메이");
	}
	public void lClick() { // 오버라이딩
		System.out.println("좌클릭 : 냉각총");
	}
	public void rClick() { // 오버라이딩
		System.out.println("우클릭 : 고드름 투사체");
	}
	public void shiftButton() { // 오버라이딩
		System.out.println("shift : 급속 빙결");
	}
	public void eButton() { // 오버라이딩
		System.out.println("e : 빙벽");
	}
	public void qButton() { // 오버라이딩
		System.out.println("q : 눈보라(궁극기)");
	}
}

class Reaper implements OverWatch { // 인터페이스 구현 클래스
	public void name() { // 오버라이딩
		System.out.println("이름 : 리퍼");
	}
	public void lClick() { // 오버라이딩
		System.out.println("좌클릭 : 헬파이어 샷건");
	}
	public void rClick() { // 오버라이딩
		System.out.println("우클릭 : 없음");
	}
	public void shiftButton() { // 오버라이딩
		System.out.println("shift : 망령화");
	}
	public void eButton() { // 오버라이딩
		System.out.println("e : 그림자 밟기");
	}
	public void qButton() { // 오버라이딩
		System.out.println("q : 죽음의 꽃(궁극기)");
	}
}

class Mccree implements OverWatch { // 인터페이스 구현 클래스
	public void name() { // 오버라이딩
		System.out.println("이름 : 맥크리");
	}
	public void lClick() { // 오버라이딩
		System.out.println("좌클릭 : 피스키퍼");
	}
	public void rClick() { // 오버라이딩
		System.out.println("우클릭 : 모든 총알 발사");
	}
	public void shiftButton() { // 오버라이딩
		System.out.println("shift : 구르기");
	}
	public void eButton() { // 오버라이딩
		System.out.println("e : 섬광탄");
	}
	public void qButton() { // 오버라이딩
		System.out.println("q : 황야의 무법자(궁극기)");
	}
}

public class PolymorphismEx01 {
	public static void main(String[] args) { // main 메소드
		OverWatch ow; // 인터페이스 객체 선언
		System.out.println("플레이할 캐릭터 번호 선택(1. 메이, 2. 리퍼, 3. 맥크리)");
		Scanner sc = new Scanner(System.in); // 스캐너 객체
		int n = sc.nextInt();
		if(n==1){
			ow = new Mei(); // 업캐스팅
		}else if(n==2){
			ow = new Reaper(); // 업캐스팅
		}else{
			ow = new Mccree(); // 업캐스팅
		}
// 선택한 조건에 따라서 부모 객체로 자식 메소드 사용(하나의 타입으로 다양한 결과를 얻어냄 / 다형성)
		ow.name();
		ow.lClick();
		ow.rClick();
		ow.shiftButton();
		ow.eButton();
		ow.qButton();
	}
}

우선 OverWatch라는 인터페이스를 정의하고 추상 메소드를 선언하였다. 이것을 구현하는 클래스 3개(Mei, Reaper, Mccree)를 정의하고 메소드를 재정의(오버라이딩) 하였다.
main 메소드에서 인터페이스(OverWatch) 객체를 선언하고 플레이할 캐릭터의 번호를 입력한다. if문에서 플레이할 캐릭터에 따라서 자식 클래스를 부모 객체로 업캐스팅 하고 부모 객체를 통해서 자식 메소드를 호출하는 내용이다.
즉, 플레이할 캐릭터에 따라서 인터페이스를 통해 아래와 같이 다양한 결과를 얻어낼 수 있고 이것이 다형성을 의미한다.
