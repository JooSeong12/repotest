class : 객체를 만들어 내기 위한 설계도 혹은 틀이며 연관되어 있는 변수와 메서드의 집합
클래스는 변수로 생각해야한다.
ex) people이라는 클래스가 있다고 가정
public class people{
변수, 메서드 등을 가질 수 있음
}

클래스 생성 시 약속
1. private 선언하자
2. getter, setter를 만들어주자 >> 변수의 값을 변경하거나 읽어올 수 있는 통로를 만들어주자

객체(object) : 소프트웨어 세계에서 구현할 대상, 클래스에 선언된 모양 그대로 생성된 실체
                  클래스의 인스턴스(instance)라고도 부르며 객체는 모든 인스턴스를 대표하는 포괄적인 의미
인스턴스(instance) : 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
                           객체를 소프트웨어에 실체화하면 그것을 인스턴스라고 부르고 실체화된 인스턴스는 메모리에 할당된다.

전역변수(Global variable)와 지역변수(Local variables)는 선언 위치에따라 나뉜다
전역변수는 어디서든 호출하면 사용할 수 있는 변수(클래스 네임 바로 밑에 선언하는 변수들)
지역변수는 특정한 구역{ }안에 생성되어 그 지역에서만 사용할 수 있는 변수(메서드 안에 선언되는 변수들)

전역변수의 종류
객체변수(인스턴스 변수) : 클래스의 객체를 생성할 때 만들어지며 객체화를 시켜야만 호출 가능 ex) int i; 
클래스변수(static 변수) : 객체화 시키지 않아도 사용 가능 ex) static int i;

클래스의 구성
필드 : 필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳입니다. 선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지는 않습니다.
        필드는 클래스 내부이면서 메소드와 생성자의 밖에 존재하는 것을 뜻한다.(전역변수의 위치를 생각하면 됨)
생성자 : new 연산자로 호출되는 특별한 중괄호 {} 블록입니다. 생성자의 역할은 객체 생성 시 초기화를 담당합니다. 
메서드 : 메서드는 객체 간의 데이터 전달의 수단

메모리구조
Static : 전역변수와 정적 멤버변수(static이 붙은 자료형)가 static영역에 저장되며 프로그램 시작부터 종료까지 메모리에 남아있는다.

Stack : 메소드 내에서 정의하는 기본 자료형(int, boolean 등)에 해당되는 지역변수의 데이터값이 저장되는 공간
          메소드가 호출될 때 메모리에 할당되고 종료시 사라짐

Heap : 참조형(Reference Type)의 데이터 타입을 갖는 객체(인스턴스), 배열 등은 Heap 영역에 데이터가 저장
          변수는 스택영역의 공간에서 실제 데이터가 저장된 heap 영역의 참조값을 new연산자를 통해 리턴받는다.
          즉 heap영역은 데이터를 저장해놓고 스택에서 참조해 쓰는 영역

오버로딩(Overloading)
1개의 클래스에서 동일한 이름의 메소드 또는 생성자를 여러개 정의하는 것을 의미한다.
동일한 이름을 갖고 매개변수의 자료형, 개수, 순서를 다르게 하여 선언하여야 한다.

인스턴스 멤버
인스턴스가 가지고 있는 필드(Field) 및 메소드(Method)를 의미하며 이들은 인스턴스 필드, 인스턴스 메소드라고 부른다.
ex) Car car = new Car() >> 인스턴스 생성 및 생성자 호출
     car.speedUp(); >> 인스턴스 메소드 호출
즉 인스턴스를 생성한 후 해당 인스턴스가 가지고 있는 필드 및 메소드를 인스턴스 멤버라고 한다.
(여기 예시에서는 speedUp()메소드가 인스턴스 메소드임)

정적멤버(클래스멤버)
정적(static) 멤버는 클래스에 소속된 멤버(필드, 메소드)를 의미한다. 
간단히 말하면 static이라는 키워드가 붙은 필드(전역변수) 또는 메소드가 정적 멤버이다.

정적 필드(변수)는 인스턴스 생성 없이 클래스로 호출이 가능하기 때문에 여러 인스턴스들이 동일한 데이터를 사용할 때
공유의 목적으로 사용하는것이다.

정적 메소드도 정적 필드와 동일한 목적이지만 정적메소드에서는 정적 필드만 사용이 가능하다.

상속(Inheritance)
자식 클래스가 부모 클래스로부터 상속을 받게 되면 부모 클래스의 필드와 메서드를 물려받게 된다.
단, 접근제어자가 private를 갖는 필드나 메소드는 상속 불가
상속을 받으면 중복된 코드를 줄이고 유지보수가 편하다.
자식클래스가 여러 부모로부터 다중 상속을 받는 것은 불가하고 1개의 부모 클래스로부터 단일 상속만 허용
하지만 부모클래스는 여러개의 자식 클래스에게 상속 가능

상속에서의 생성자
기본적으로 생성자는 상속되지 않는다.
자식 클래스로 인스턴스를 생성할 때 부모 클래스의 기본 생성자는 자동으로 호출이 된다.
하지만 부모 클래스에 매개변수를 갖는 생성자가 있다면 이 생성자는 자동으로 호출 되지 않으며
해당 생성자를 호출 하고 싶다면 자식 생성자 안에 super();라는 키워드를 첫줄에 작성해야한다.
super();의 괄호 안에는 부모 클래스의 매개변수 생성자와 동일한 매개변수를 넣어줘야한다.

싱글톤(Singleton) 패턴
하나의 해당 클레스에서 단 하나의 인스턴스만 만들도록 보장하는 방법
하나의 인스턴스만을 재사용함으로서 불필요한 자원 낭비나 오버헤드 등을 방지

1. 외부에서 생성자를 호출할 수 없도록 제한, 즉 생성자의 접근제어자를 private로 사용
2. 자신의 클래스 타입으로 정적(static) 필드를 선언하고 자신의 인스턴스를 생성 접근제어자도 private
3. 외부에서 호출이 가능한 정적 메소드인 getInstance()를 정의, 정적필드에서 생성한 인스턴스를 리턴값으로 돌려줌
   외부 클래스에서 싱글톤으로 정의된 클래스의 인스턴스를 얻기 위해서는 getInstance()메서드를 호출해야함
그렇다면 아래의 모양이 된다.

class 클래스명 {
private static 클래스명 객체명 = new 클래스명(); // 자신의 인스턴스 생성
private 클래스명(){} // 생성자 호출 제한
public static 클래스명 getInstance(){ // getInstance 메서드 정의
return 객체명; // 생성한 인스턴스를 리턴
}
}

오버라이딩(overriding)
부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하여 사용하는 것
자식 클래스에서 부모 클래스의 메소드를 재정의 하기위해서는 조건을 지켜야한다.
부모 메소드의 이름, 리턴타입, 매개변수의 갯수, 자료형과 순서를 동일하게 해야한다.

추상클래스
abstract 키워를 class 앞에 선언
ex) abstract class 클래스명{}
추상메서드도 동일하게 abstract 리턴타입 메소드명(매개변수); >> 얘는 중괄호 없이 바로 ;으로 종료

추상 클래스 및 메소드 특징
1. 자체적으로 객체를 생성할 수 없고, 상속을 통해 자식클래스에서 인스턴스를 생성해야함
2. 추상클래스는 추상 메소드, 일반 메소드, 필드, 생성자로 구성
3. 일반적인 상속의 특성과 동일
4. 추상클래스를 상속받는 클래스는 반드시 추상 메소드를 오버라이딩해야한다.

추상클래스를 사용하는 이유는 다수의 사람이 개발에 참여할 때 공통된 내용들은
통일되게 작성하도록 규격화하기 위함이다.

final
변경이나 수정을 금지하는 것

final field
final을 가장 많이 사용하는 곳은 필드이다.
final로 변수값을 지정하면 다른곳에서 변경이 불가하다.

final class
final class의 의미는 상속이 불가능하다는것을 의미한다.

final method
final method의 의미는 오버라이딩을 금지할 때 사용

인터페이스(interface)
